# [20251030] Triggers e Procedures

[Link da Aula](https://www.notion.so/20251030-DQL-Consultas-Agregadas-259256ceaea780db82d1cd0f1da26134?pvs=21)

## Objetivos da Aula

- Compreender o conceito de Procedures (Procedimentos Armazenados)
- Compreender o conceito de Triggers
- Criar procedures básicas no Oracle SQL
- Criar triggers básicos no Oracle SQL
- Aplicar triggers e procedures em situações práticas

---

## Preparação: Criando as Tabelas

Primeiro, vamos criar a tabela de vendas e a tabela de logs:

```sql
-- Tabela de Vendas
CREATE TABLE VENDAS (
    id            NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    produto       VARCHAR2(100) NOT NULL,
    categoria     VARCHAR2(50)  NOT NULL,
    valor         NUMBER(10,2)  NOT NULL CHECK (valor > 0),
    data_venda    DATE          DEFAULT SYSDATE,
    vendedor      VARCHAR2(100) NOT NULL
);

-- Tabela de Logs (para registrar todas as operações)
CREATE TABLE LOG_VENDAS (
    id            NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    operacao      VARCHAR2(20)  NOT NULL,  -- INSERT, UPDATE, DELETE
    id_venda      NUMBER,
    produto       VARCHAR2(100),
    vendedor      VARCHAR2(100),
    valor         NUMBER(10,2),
    usuario       VARCHAR2(100) DEFAULT USER,
    data_hora     DATE          DEFAULT SYSDATE,
    observacao    VARCHAR2(500)
);

-- Inserir dados iniciais na tabela VENDAS
INSERT INTO VENDAS (produto, categoria, valor, data_venda, vendedor) 
VALUES 
    ('Notebook Dell', 'Eletrônicos', 4500.00, DATE '2025-04-01', 'Carlos'),
    ('Mouse Gamer', 'Acessórios', 150.00, DATE '2025-04-01', 'Ana'),
    ('Teclado Mecânico', 'Acessórios', 300.00, DATE '2025-04-02', 'Carlos'),
    ('Monitor 24"', 'Eletrônicos', 1200.00, DATE '2025-04-02', 'Bruna'),
    ('Fone Bluetooth', 'Acessórios', 200.00, DATE '2025-04-03', 'Ana'),
    ('Notebook HP', 'Eletrônicos', 4000.00, DATE '2025-04-03', 'Carlos'),
    ('Webcam HD', 'Acessórios', 180.00, DATE '2025-04-04', 'Bruna'),
    ('Carregador Portátil', 'Acessórios', 120.00, DATE '2025-04-04', 'Ana'),
    ('SSD 1TB', 'Componentes', 500.00, DATE '2025-04-05', 'Carlos'),
    ('Cabo HDMI', 'Acessórios', 50.00, DATE '2025-04-05', 'Bruna');

COMMIT;
```

---

## 1. O que são Triggers?

**Triggers** (Gatilhos) são blocos de código PL/SQL que são executados automaticamente quando ocorre um evento específico em uma tabela, como INSERT, UPDATE ou DELETE.

### Características principais:

- Executam automaticamente (você não precisa chamá-los)
- Podem executar **antes** (BEFORE) ou **depois** (AFTER) da operação
- Podem executar **para cada linha** (FOR EACH ROW) ou uma vez por comando
- São úteis para auditoria, validação e manutenção automática de dados

### Sintaxe Básica:

```sql
CREATE [OR REPLACE] TRIGGER nome_trigger
BEFORE | AFTER
INSERT | UPDATE | DELETE
ON nome_tabela
[FOR EACH ROW]
BEGIN
    -- Código que será executado
END;
/
```

---

## 2. Criando nossa Trigger de Log

Vamos criar uma trigger que registra automaticamente em LOG_VENDAS sempre que uma nova venda for inserida:

```sql
CREATE OR REPLACE TRIGGER trg_log_insert_vendas
AFTER INSERT ON VENDAS
FOR EACH ROW
BEGIN
    INSERT INTO LOG_VENDAS (
        operacao,
        id_venda,
        produto,
        vendedor,
        valor,
        usuario,
        data_hora,
        observacao
    ) VALUES (
        'INSERT',
        :NEW.id,
        :NEW.produto,
        :NEW.vendedor,
        :NEW.valor,
        USER,
        SYSDATE,
        'Nova venda inserida: ' || :NEW.produto || ' vendido por ' || :NEW.vendedor
    );
END;
/
```

### Explicação do Código:

- **`AFTER INSERT ON VENDAS`**: A trigger executa DEPOIS que um INSERT é feito na tabela VENDAS
- **`FOR EACH ROW`**: A trigger executa para CADA linha inserida
- **`:NEW`**: Referencia os valores da linha que está sendo inserida
- **`USER`**: Função do Oracle que retorna o usuário atual do banco
- **`SYSDATE`**: Função que retorna a data e hora atual

### Testando a Trigger:

```sql
-- Inserir uma nova venda (a trigger será executada automaticamente)
INSERT INTO VENDAS (produto, categoria, valor, vendedor)
VALUES ('Tablet Samsung', 'Eletrônicos', 1800.00, 'Ana');

COMMIT;

-- Verificar se o log foi criado automaticamente
SELECT * FROM LOG_VENDAS
ORDER BY data_hora DESC;
```

---

## 3. O que são Procedures?

**Procedures** (Procedimentos Armazenados) são blocos de código PL/SQL nomeados que podem ser chamados quando necessário. Diferente das triggers que executam automaticamente, as procedures precisam ser chamadas explicitamente.

### Características principais:

- Executam apenas quando são chamadas
- Podem receber parâmetros de entrada (IN) e retornar valores (OUT)
- Podem encapsular lógica complexa
- Promovem reutilização de código

### Sintaxe Básica:

```sql
CREATE [OR REPLACE] PROCEDURE nome_procedure
(
    parametro1 [IN|OUT|IN OUT] tipo_dado,
    parametro2 [IN|OUT|IN OUT] tipo_dado
)
IS
    -- Variáveis locais (opcional)
BEGIN
    -- Lógica da procedure
END nome_procedure;
/
```

---

## 4. Criando nossa Procedure para Consultar Logs

Vamos criar uma procedure que consulta os logs de vendas de um vendedor específico:

```sql
CREATE OR REPLACE PROCEDURE consultar_logs_vendedor
(
    p_vendedor IN VARCHAR2,
    p_total_logs OUT NUMBER
)
IS
BEGIN
    -- Contar quantos logs existem para o vendedor
    SELECT COUNT(*)
    INTO p_total_logs
    FROM LOG_VENDAS
    WHERE vendedor = p_vendedor;
    
    -- Exibir os logs do vendedor
    DBMS_OUTPUT.PUT_LINE('=== Logs de Vendas do Vendedor: ' || p_vendedor || ' ===');
    DBMS_OUTPUT.PUT_LINE('Total de registros: ' || p_total_logs);
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('ID | Produto | Valor | Data/Hora');
    DBMS_OUTPUT.PUT_LINE('-----------------------------------------------');
    
    -- Exibir cada log
    FOR registro IN (
        SELECT id_venda, produto, valor, TO_CHAR(data_hora, 'DD/MM/YYYY HH24:MI:SS') as data_formatada
        FROM LOG_VENDAS
        WHERE vendedor = p_vendedor
        ORDER BY data_hora DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            registro.id_venda || ' | ' ||
            registro.produto || ' | ' ||
            'R$ ' || registro.valor || ' | ' ||
            registro.data_formatada
        );
    END LOOP;
END consultar_logs_vendedor;
/
```

### Explicação do Código:

- **`p_vendedor IN VARCHAR2`**: Parâmetro de entrada (recebe um valor)
- **`p_total_logs OUT NUMBER`**: Parâmetro de saída (retorna um valor)
- **`DBMS_OUTPUT.PUT_LINE`**: Exibe mensagens no console (precisa habilitar com `SET SERVEROUTPUT ON`)
- **`FOR ... LOOP`**: Loop que percorre os resultados de uma query

### Executando a Procedure:

```sql
-- Habilitar exibição de mensagens
SET SERVEROUTPUT ON;

-- Declarar variável para receber o resultado
DECLARE
    v_total NUMBER;
BEGIN
    consultar_logs_vendedor('Ana', v_total);
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Total retornado: ' || v_total);
END;
/
```

---

## 5. Testando tudo Junto

Vamos fazer um teste completo:

```sql
-- 1. Habilitar mensagens
SET SERVEROUTPUT ON;

-- 2. Inserir novas vendas (a trigger criará os logs automaticamente)
INSERT INTO VENDAS (produto, categoria, valor, vendedor)
VALUES ('Smartphone', 'Eletrônicos', 2500.00, 'Carlos');

INSERT INTO VENDAS (produto, categoria, valor, vendedor)
VALUES ('Mouse Pad', 'Acessórios', 80.00, 'Bruna');

COMMIT;

-- 3. Verificar os logs criados pela trigger
SELECT 
    id,
    operacao,
    produto,
    vendedor,
    valor,
    TO_CHAR(data_hora, 'DD/MM/YYYY HH24:MI:SS') AS data_hora
FROM LOG_VENDAS
ORDER BY data_hora DESC;

-- 4. Usar a procedure para consultar logs de um vendedor
DECLARE
    v_total NUMBER;
BEGIN
    consultar_logs_vendedor('Carlos', v_total);
END;
/
```

---

## 6. Comandos Úteis

```sql
-- Habilitar mensagens DBMS_OUTPUT (no Oracle SQL Developer ou SQL*Plus)
SET SERVEROUTPUT ON;

-- Ver todas as triggers criadas
SELECT trigger_name, table_name, status
FROM user_triggers
WHERE table_name = 'VENDAS';

-- Ver todas as procedures criadas
SELECT object_name, object_type
FROM user_objects
WHERE object_type = 'PROCEDURE';

-- Desabilitar uma trigger temporariamente
ALTER TRIGGER trg_log_insert_vendas DISABLE;

-- Habilitar uma trigger novamente
ALTER TRIGGER trg_log_insert_vendas ENABLE;

-- Apagar uma trigger
DROP TRIGGER trg_log_insert_vendas;

-- Apagar uma procedure
DROP PROCEDURE consultar_logs_vendedor;
```

---

## 7. Diferenças entre Trigger e Procedure

| **Trigger** | **Procedure** |
|-------------|---------------|
| Executa automaticamente | Precisa ser chamada explicitamente |
| Não pode receber parâmetros diretamente | Pode receber parâmetros |
| Não pode retornar valores | Pode retornar valores (OUT) |
| Usado para auditoria, validação | Usado para lógica de negócio reutilizável |
| Executado pelo Oracle | Executado pelo usuário/aplicação |

---

## 8. Exercícios Práticos

### Exercício 1
Crie uma trigger que também registre logs quando houver UPDATE na tabela VENDAS.

### Exercício 2
Crie uma procedure chamada `total_vendas_vendedor` que recebe o nome do vendedor e retorna o total de vendas realizadas por ele.

### Exercício 3
Crie uma trigger BEFORE INSERT que valide se o valor da venda é maior que zero antes de permitir a inserção.

---

## 9. Recursos Adicionais

- **Oracle Live SQL**: https://livesql.oracle.com - Plataforma para testar código SQL/PL-SQL
- **Documentação Oracle PL/SQL**: Oracle Documentation
- **SQL Developer**: Ferramenta gratuita da Oracle para trabalhar com bancos de dados

---

## 10. Resumo do que Aprendemos

✅ **Criamos uma tabela de logs** para registrar operações  
✅ **Criamos uma trigger** que registra automaticamente quando há INSERT em VENDAS  
✅ **Criamos uma procedure** para consultar logs de vendedores  
✅ **Entendemos a diferença** entre triggers (automáticos) e procedures (chamadas manualmente)  
✅ **Testamos** tudo funcionando junto  

As triggers e procedures são ferramentas poderosas que nos ajudam a manter a integridade dos dados e automatizar tarefas no banco de dados!
